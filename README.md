# utree
A rebalancing binary tree for JS

> Based on [btree](https://github.com/QuotableWater7/btree) 
by [JT Bowler](https://github.com/QuotableWater7)

## Install
```sh
npm install --save utree
```

## Require / Import
```js
var Tree = require('utree')
// or
import Tree from 'utree'
```

## Creating a tree
Create a tree by calling the constructor. Optionally pass an options object.

```js
var tree = new Tree();
// or
var tree = new Tree({ /* options object */ })
```

## Example
```js
var Tree = require('utree');
var log = require('ulog')('example')
var pretty = require('utree/pretty')

var tree = new Tree()

tree.insert(5, 3, 10, 8)
log.info(pretty(tree))

//         5
//
//    3              10
//
//              8

tree.delete(3)
log.info(pretty(tree))

//         8
//
//    5         10
```

## Demo
A small demo is included with the project.
To run it:

```sh
npm run demo
```

Output:

```sh

                                                                       13
                                         7                                                     17
                 3                                   9                             15                                   22
     1                       5                 8                 11           14           16                 19                 25
           2           4           6                       10                                         18           21                 30
```

Code:

*printer.js*

```js
var log = require('ulog')('printer')
var Tree = require('../src/tree')
var pretty = require('../src/pretty')

log.info(pretty(new Tree().insert(
  1, 3, 5, 2, 4, 6, 7, 8, 9, 15, 11, 13, 17, 18, 14, 19, 25, 30, 22, 21, 10, 16
)))
```

## Options
You can pass an options object to the Tree constructor with these options.

### unique
The binary tree defaults to allowing multiple identical keys.  
If `unique: true` is passed in as an option, it will throw an error when inserting 
a duplicate key.

```js
var tree = new Tree({ unique: true });
tree.insert(1, 1);  // throws duplicate key violation
```

### key
When used to store objects, the binary tree defaults to using the `id`
property of the object as the key:

```js
var tree = new Tree();
tree.insert({id: 1});
console.log(tree.root.key); // 1
```

This can be changed by specifying the property name for the key property 
in the options object:

```js
var tree = new Tree({key: 'myId'});
tree.insert({myId: 1});
console.log(tree.root.key); // 1
```

Compound keys are supported by specifying an array containing the names of the 
properties that make up the key:

```js
var tree = new Tree({ key: ['orderId', 'orderLineId'] });
tree.insert({orderId:7, orderLineId:1});
console.log(tree.root.key); // [7, 1]
```

When using compound keys, the key property will hold an array of values,
the order of which corresponds to the order of the names specified in the `key` option.

For trees storing objects with compound keys, a compare function is automatically 
generated based on the specified property names unless one has been specified explicitly 
in the tree options (see below). If the properties relate to each other in a way that 
influences comparisons, the order of the property names in the array dictates which 
of the properties hold the most significance. For example supposing we wanted to 
store dates as objects with `day`, `month` and `year` fields, we would have to specify
the year field first as it is most significant for sort order:

```js
var tree = new Tree({ key: ['year', 'month', 'day'] });
tree.insert({month:1, day:31, year:2017});
console.log(tree.root.key); // [2017, 1, 31]
```

### compare
When using the tree to store objects, you can influence how they are compared by 
specifying a compare function:

```js
var tree = new Tree({
  key: ['year', 'month', 'day'], 
  compare: function(one, other) {
    if ((one.year < other.year) || 
        (one.year === other.year && one.month < other.month) ||
        (one.year === other.year && one.month === other.month && one.day < other.day)) {
      return -1;
    }
    if ((one.year > other.year) || 
        (one.year === other.year && one.month > other.month) ||
        (one.year === other.year && one.month === other.month && one.day > other.day)) {
      return 1;
    }
    return 0;
  },
});
```

> Note that in the example above, the compare function is not actually useful as the 
function generated by utree already has this behavior. A better example for a custom 
compare function might be one that does case insensitive comparisons based on Unicode 
collation rules. Because the default compare functions used by utree perform case 
sensitive comparisons.

## API
The tree has a small API that should cover interacting with it. Each tree may have at 
most one `root` node. Each node may contain one or more items with the same key (or 
just one if `unique` was set to `true` in the tree options). Each node has a `key` property 
that determines where in the tree the node will be stored. Each node has a `values` property 
that either contains an array with the value(s) or is `undefined` if the key is the value. 
Each node has a (calculated) `value` property that will return the first value from the 
`values` array, or the key if the `values` array is `undefined`. Additionally, each node 
can itself be a subtree with optional `left` and `right` sub-subtrees and a `parent`. 

Mostly, you won't have to deal with nodes directly, except for grabbing the `key`, `value`
or `values` from it. You will probably mostly use the properties and methods on the tree 
itself, which are described below.

### size
The amount of items in the tree. Read-only property.
This property is not called length to prevent confusion with arrays.

### root
The root node if any, or `undefined`.

### isEmpty()
Returns whether or not the tree has items in it.

```js
var tree = new Tree();
console.log(tree.isEmpty()); // true

tree.insert({ key: 6 });
console.log(tree.isEmpty()); // false

tree.delete(6);
console.log(tree.isEmpty()); // true
```

### delete(item)
Deletes an item from the tree. 
If the tree becomes unbalanced as a result, it will rebalance itself.

#### item
Either a node or the key for a node to delete from the tree.  

```js
tree.insert(5, 3, 10, 8)
log.info(pretty(tree))

//         5
//
//    3              10
//
//              8

tree.delete(3)
log.info(pretty(tree))

//         8
//
//    5         10
```

> Note how the root node is now `8` instead of `5`

### min(node)
Returns the minimum item in the tree.  

#### node
An optional context node. If provided, it will find the minimum item in that subtree.

```js
tree.insert(50, 25, 90, 180, 40);
log.info(tree.min().key); // 25

tree.delete(tree.min());
log.info(tree.min().key); // 40
```

### max(node)
Returns the maximum item in the tree. 

#### node
An optional context node. If provided, it will find the maximum item in that subtree.

```js
tree.insert(50, 25, 90, 180, 40);
log.info(tree.max().key); // 180

tree.delete(tree.max());
log.info(tree.max().key); // 90
```

### find(key)
Finds the item(s) with the given key.  If not found, returns an empty array `[]`.

```js
tree.insert(
  {key: 10, text: 'foo'},
  {key: 10, text: 'bar'},
  {key: 15, text: 'baz'}
)

var nodes = tree.find(15)
log.info(nodes.length)         // 1
log.info(nodes[0].value.text)  // baz
log.info(nodes[0].parent.key)  // 10

nodes = tree.find(10)
log.info(nodes.length)         // 2
log.info(nodes[0].value.text)  // foo
log.info(nodes[1].value.text)  // bar
log.info(nodes[0].parent)      // undefined

nodes = tree.find(1)
log.info(nodes.length)         // 0
log.info(nodes[0])             // undefined
```

### height
Returns the height of the tree.  With `n` nodes, the height of the
tree will be approximately `log(n)`.

```js
var tree = new Tree();
tree.insert(10, 5, 15, 2, 7, 12, 18);
tree.height();  // 3
```

### forEach(fn, order)
An iterator that invokes `fn` for each node in the given `order`

```js
tree.forEach(function (node) {
  console.log(node.data.key);
});
```

#### fn(node, idx, depth)
The function that will be invoked for each node. Required.

##### node
The node currently being visited

##### idx
The index of the current node (starting at `0`)

##### depth
The depth of the current node (where the root node is at level `1`)

#### order 
One of `Tree.PRE_ORDER`, `Tree.IN_ORDER` or `Tree.POST_ORDER`. Defaults to `Tree.IN_ORDER`.

The default case, `IN_ORDER`, visits the node in order of key:

1. Return node from left tree (recursive)
2. Return self
3. Return node from right tree (recursive)



#### preOrderTraversal
An iterator that returns the nodes via:

1. Return self
2. Return node from left tree (recursive)
3. Return node from right tree (recursive)

```javascript
tree.preOrderTraversal(function (node) {
  console.log(node.value);
});
```


#### postOrderTraversal
An iterator that returns the nodes via:

1. Return node from left tree (recursive)
2. Return node from right tree (recursive)
3. Return self

```javascript
tree.postOrderTraversal(function (node) {
  console.log(node.value);
});
```

## Extra utilitie

### pretty
Pretty print a string with the keys in the tree.

```js
var log = require('ulog')('pretty-example')
var Tree = require('utree')
var pretty = require('utree/pretty')

var tree = new Tree()
tree.insert(5, 3, 10, 8)
log.info(pretty(tree))

//         5
//
//    3              10
//
//              8
```


Written by JT Bowler, 2016.
